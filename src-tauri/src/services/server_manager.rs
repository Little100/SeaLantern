use std::collections::HashMap;
use std::io::{BufRead, BufReader, Write, Read};
use std::process::{Child, Command, Stdio};
use std::sync::Mutex;
use std::time::{SystemTime, UNIX_EPOCH};

use crate::models::server::*;

const DATA_FILE: &str = "sea_lantern_servers.json";

pub struct ServerManager {
    pub servers: Mutex<Vec<ServerInstance>>,
    pub processes: Mutex<HashMap<String, Child>>,
    pub logs: Mutex<HashMap<String, Vec<String>>>,
    pub data_dir: Mutex<String>,
    pub commands_cache: Mutex<HashMap<String, Vec<String>>>,
}

impl ServerManager {
    pub fn new() -> Self {
        let data_dir = get_data_dir();
        let servers = load_servers(&data_dir);
        let mut logs_map = HashMap::new();
        for s in &servers { logs_map.insert(s.id.clone(), Vec::new()); }
        ServerManager {
            servers: Mutex::new(servers),
            processes: Mutex::new(HashMap::new()),
            logs: Mutex::new(logs_map),
            data_dir: Mutex::new(data_dir),
            commands_cache: Mutex::new(HashMap::new()),
        }
    }

    fn save(&self) {
        let servers = self.servers.lock().unwrap();
        let data_dir = self.data_dir.lock().unwrap();
        save_servers(&data_dir, &servers);
    }

    fn get_app_settings(&self) -> crate::models::settings::AppSettings {
        super::global::settings_manager().get()
    }

    pub fn create_server(&self, req: CreateServerRequest) -> Result<ServerInstance, String> {
        let id = uuid::Uuid::new_v4().to_string();
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        let jar_path_obj = std::path::Path::new(&req.jar_path);
        let server_dir = jar_path_obj.parent()
            .map(|p| p.to_string_lossy().to_string())
            .unwrap_or_else(|| ".".to_string());

        let server = ServerInstance {
            id: id.clone(), name: req.name, core_type: req.core_type,
            core_version: String::new(), mc_version: req.mc_version,
            path: server_dir, jar_path: req.jar_path, java_path: req.java_path,
            max_memory: req.max_memory, min_memory: req.min_memory,
            jvm_args: Vec::new(), port: req.port, created_at: now, last_started_at: None,
        };
        self.servers.lock().unwrap().push(server.clone());
        self.logs.lock().unwrap().insert(id, Vec::new());
        self.save();
        Ok(server)
    }

    pub fn import_server(&self, req: ImportServerRequest) -> Result<ServerInstance, String> {
        let source_jar = std::path::Path::new(&req.jar_path);
        if !source_jar.exists() {
            return Err(format!("JAR file not found: {}", req.jar_path));
        }

        let server_dir = source_jar.parent()
            .ok_or_else(|| "无法获取JAR文件所在目录".to_string())?;

        let id = uuid::Uuid::new_v4().to_string();

        let server_properties_path = server_dir.join("server.properties");
        if !server_properties_path.exists() {
            let server_properties_content = format!(
                "# Minecraft server properties\n\
                 # Generated by SeaLantern\n\
                 server-port={}\n\
                 online-mode={}\n",
                req.port,
                req.online_mode
            );
            std::fs::write(&server_properties_path, server_properties_content)
                .map_err(|e| format!("创建 server.properties 失败: {}", e))?;
            println!("已创建 server.properties: {}", server_properties_path.display());
        } else {
            println!("server.properties 已存在，保留原有配置: {}", server_properties_path.display());
        }

        // 创建服务器实例
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        let server = ServerInstance {
            id: id.clone(),
            name: req.name,
            core_type: "unknown".into(),
            core_version: String::new(),
            mc_version: "unknown".into(),
            path: server_dir.to_string_lossy().to_string(),
            jar_path: req.jar_path,
            java_path: req.java_path,
            max_memory: req.max_memory,
            min_memory: req.min_memory,
            jvm_args: Vec::new(),
            port: req.port,
            created_at: now,
            last_started_at: None,
        };

        self.servers.lock().unwrap().push(server.clone());
        self.logs.lock().unwrap().insert(id, Vec::new());
        self.save();
        Ok(server)
    }

    pub fn import_modpack(&self, req: ImportModpackRequest) -> Result<ServerInstance, String> {
        let source_path = std::path::Path::new(&req.modpack_path);
        if !source_path.exists() {
            return Err(format!("整合包文件夹不存在: {}", req.modpack_path));
        }
        if !source_path.is_dir() {
            return Err("所选路径不是文件夹".to_string());
        }

        // 查找服务端JAR文件
        let source_jar = find_server_jar(source_path)?;
        println!("找到服务端JAR文件: {}", source_jar);

        // 直接使用整合包文件夹作为服务器目录
        let id = uuid::Uuid::new_v4().to_string();
        let server_dir = source_path;

        // 创建服务器实例
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        let server = ServerInstance {
            id: id.clone(),
            name: req.name,
            core_type: "modpack".into(),
            core_version: String::new(),
            mc_version: "unknown".into(),
            path: server_dir.to_string_lossy().to_string(),
            jar_path: source_jar,
            java_path: req.java_path,
            max_memory: req.max_memory,
            min_memory: req.min_memory,
            jvm_args: Vec::new(),
            port: req.port,
            created_at: now,
            last_started_at: None,
        };

        println!("创建服务器实例: id={}, path={}, jar_path={}", server.id, server.path, server.jar_path);

        self.servers.lock().unwrap().push(server.clone());
        self.logs.lock().unwrap().insert(id, Vec::new());
        self.save();
        Ok(server)
    }

    pub fn start_server(&self, id: &str) -> Result<(), String> {
        let server = {
            let servers = self.servers.lock().unwrap();
            servers.iter().find(|s| s.id == id)
                .ok_or_else(|| "未找到服务器".to_string())?.clone()
        };

        println!("准备启动服务器: id={}, name={}, jar_path={}, java_path={}",
                 server.id, server.name, server.jar_path, server.java_path);

        // Check if already running
        {
            let mut procs = self.processes.lock().unwrap();
            if let Some(child) = procs.get_mut(id) {
                match child.try_wait() {
                    Ok(Some(_)) => { procs.remove(id); } // Dead process, clean up
                    Ok(None) => return Err("服务器已在运行中".to_string()),
                    Err(_) => { procs.remove(id); }
                }
            }
        }

        let settings = self.get_app_settings();
        if settings.auto_accept_eula {
            let eula = std::path::Path::new(&server.path).join("eula.txt");
            let _ = std::fs::write(&eula, "# Auto-accepted by Sea Lantern\neula=true\n");
        }

        // 使用最简单的方式直接启动Java
        let mut cmd = Command::new(&server.java_path);
        cmd.arg(format!("-Xmx{}M", server.max_memory));
        cmd.arg(format!("-Xms{}M", server.min_memory));

        // 强制使用UTF-8编码，避免Windows上的中文乱码问题
        cmd.arg("-Dfile.encoding=UTF-8");
        cmd.arg("-Dsun.stdout.encoding=UTF-8");
        cmd.arg("-Dsun.stderr.encoding=UTF-8");

        let jvm = settings.default_jvm_args.trim();
        if !jvm.is_empty() {
            for arg in jvm.split_whitespace() {
                cmd.arg(arg);
            }
        }

        for arg in &server.jvm_args {
            cmd.arg(arg);
        }

        cmd.arg("-jar");

        // 由于JAR文件现在都在服务器目录下，直接使用文件名
        let jar_path_obj = std::path::Path::new(&server.jar_path);
        let jar_filename = jar_path_obj.file_name()
            .map(|n| n.to_string_lossy().to_string())
            .unwrap_or_else(|| server.jar_path.clone());

        cmd.arg(&jar_filename);
        cmd.arg("nogui");

        cmd.current_dir(&server.path);

        // 使用文件重定向，避免piped导致的Java代理加载问题
        let log_file = std::path::Path::new(&server.path).join("latest.log");

        // 清空旧日志文件，避免读取历史日志
        let stdout_file = std::fs::OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&log_file)
            .map_err(|e| format!("无法创建日志文件: {}", e))?;

        let stderr_file = stdout_file.try_clone()
            .map_err(|e| format!("无法克隆文件句柄: {}", e))?;

        cmd.stdout(Stdio::from(stdout_file));
        cmd.stderr(Stdio::from(stderr_file));
        cmd.stdin(Stdio::piped());

        // 隐藏控制台窗口
        #[cfg(target_os = "windows")]
        {
            use std::os::windows::process::CommandExt;
            const CREATE_NO_WINDOW: u32 = 0x08000000;
            cmd.creation_flags(CREATE_NO_WINDOW);
        }

        let mut child = cmd.spawn().map_err(|e| format!("启动失败: {}", e))?;
        println!("Java进程已启动，PID: {:?}", child.id());

        self.processes.lock().unwrap().insert(id.to_string(), child);

        {
            let mut servers = self.servers.lock().unwrap();
            if let Some(s) = servers.iter_mut().find(|s| s.id == id) {
                s.last_started_at = Some(SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs());
            }
        }
        self.save();
        self.append_log(id, "[Sea Lantern] 服务器启动中...");

        // 启动日志读取线程
        let logs_ref = &self.logs as *const Mutex<HashMap<String, Vec<String>>>;
        let max_lines = settings.max_log_lines as usize;
        let lid = id.to_string();
        let ptr = logs_ref as usize;
        let ml = max_lines;
        let log_path = log_file.clone();

        std::thread::spawn(move || {
            use std::io::Seek;
            let mut pos = 0u64;
            let mut last_size = 0u64;

            loop {
                std::thread::sleep(std::time::Duration::from_millis(500));

                if let Ok(mut file) = std::fs::File::open(&log_path) {
                    if let Ok(metadata) = file.metadata() {
                        let len = metadata.len();

                        if len > last_size {
                            if file.seek(std::io::SeekFrom::Start(pos)).is_ok() {
                                let m = unsafe { &*(ptr as *const Mutex<HashMap<String, Vec<String>>>) };
                                let mut buffer = Vec::new();

                                if file.read_to_end(&mut buffer).is_ok() {
                                    let content = String::from_utf8_lossy(&buffer);
                                    for line in content.lines() {
                                        if !line.trim().is_empty() {
                                            if let Ok(mut l) = m.lock() {
                                                if let Some(v) = l.get_mut(&lid) {
                                                    v.push(line.to_string());
                                                    if v.len() > ml {
                                                        let d = v.len() - ml;
                                                        v.drain(0..d);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    pos = len;
                                }
                            }
                            last_size = len;
                        }
                    }
                }
            }
        });

        Ok(())
    }

    pub fn stop_server(&self, id: &str) -> Result<(), String> {
        // Check if actually running first
        let is_running = {
            let mut procs = self.processes.lock().unwrap();
            if let Some(child) = procs.get_mut(id) {
                match child.try_wait() {
                    Ok(Some(_)) => { procs.remove(id); false }
                    Ok(None) => true,
                    Err(_) => { procs.remove(id); false }
                }
            } else { false }
        };

        if !is_running {
            self.append_log(id, "[Sea Lantern] 服务器未运行");
            return Ok(());
        }

        // Send stop command
        self.append_log(id, "[Sea Lantern] 正在发送停止命令...");
        let _ = self.send_command(id, "stop");

        // Wait for graceful shutdown (up to 10 seconds)
        for _ in 0..20 {
            std::thread::sleep(std::time::Duration::from_millis(500));
            let mut procs = self.processes.lock().unwrap();
            if let Some(child) = procs.get_mut(id) {
                match child.try_wait() {
                    Ok(Some(_)) => {
                        procs.remove(id);
                        self.append_log(id, "[Sea Lantern] 服务器已正常停止");
                        return Ok(());
                    }
                    Ok(None) => {} // Still running
                    Err(_) => {
                        procs.remove(id);
                        return Ok(());
                    }
                }
            } else {
                self.append_log(id, "[Sea Lantern] 服务器已停止");
                return Ok(());
            }
        }

        // Force kill after timeout
        let mut procs = self.processes.lock().unwrap();
        if let Some(mut child) = procs.remove(id) {
            let _ = child.kill();
            let _ = child.wait();
            self.append_log(id, "[Sea Lantern] 服务器超时，已强制终止");
        }
        Ok(())
    }

    pub fn send_command(&self, id: &str, command: &str) -> Result<(), String> {
        let mut procs = self.processes.lock().unwrap();
        let child = procs.get_mut(id).ok_or_else(|| "服务器未运行".to_string())?;
        if let Some(ref mut stdin) = child.stdin {
            writeln!(stdin, "{}", command).map_err(|e| format!("发送失败: {}", e))?;
            stdin.flush().map_err(|e| format!("发送失败: {}", e))?;
        }
        Ok(())
    }

    /// 发送 Tab 补全请求到服务器
    /// 向 stdin 写入命令前缀 + Tab 字符
    pub fn send_tab_complete(&self, id: &str, prefix: &str) -> Result<(), String> {
        let mut procs = self.processes.lock().unwrap();
        let child = procs.get_mut(id).ok_or_else(|| "服务器未运行".to_string())?;
        if let Some(ref mut stdin) = child.stdin {
            // 发送命令前缀 + Tab 字符
            write!(stdin, "{}\t", prefix).map_err(|e| format!("发送失败: {}", e))?;
            stdin.flush().map_err(|e| format!("发送失败: {}", e))?;
        }
        Ok(())
    }

    /// 从日志中解析 Tab 补全结果
    pub fn get_tab_completions(&self, id: &str) -> Vec<String> {
        let logs = self.logs.lock().unwrap();
        if let Some(log_lines) = logs.get(id) {
            return parse_tab_completions(log_lines);
        }
        Vec::new()
    }

    pub fn get_server_list(&self) -> Vec<ServerInstance> {
        self.servers.lock().unwrap().clone()
    }

    pub fn get_server_status(&self, id: &str) -> ServerStatusInfo {
        let mut procs = self.processes.lock().unwrap();
        let is_running = if let Some(child) = procs.get_mut(id) {
            match child.try_wait() {
                Ok(Some(_)) => { procs.remove(id); false }
                Ok(None) => true,
                Err(_) => { procs.remove(id); false }
            }
        } else { false };
        ServerStatusInfo {
            id: id.to_string(),
            status: if is_running { ServerStatus::Running } else { ServerStatus::Stopped },
            pid: None, uptime: None,
        }
    }

    /// 仅从列表中移除服务器（不删除文件）
    pub fn remove_from_list(&self, id: &str) -> Result<(), String> {
        // Only stop if actually running
        {
            let procs = self.processes.lock().unwrap();
            if procs.contains_key(id) {
                drop(procs);
                let _ = self.stop_server(id);
            }
        }
        self.servers.lock().unwrap().retain(|s| s.id != id);
        self.logs.lock().unwrap().remove(id);
        self.save();
        Ok(())
    }

    /// 删除服务器及其所有文件
    pub fn delete_server_files(&self, id: &str) -> Result<(), String> {
        // 获取服务器路径
        let server_path = {
            let servers = self.servers.lock().unwrap();
            servers.iter().find(|s| s.id == id).map(|s| s.path.clone())
        };

        // 先从列表移除
        self.remove_from_list(id)?;

        // 删除服务器文件夹
        if let Some(path) = server_path {
            let server_dir = std::path::Path::new(&path);
            if server_dir.exists() && server_dir.is_dir() {
                std::fs::remove_dir_all(server_dir)
                    .map_err(|e| format!("删除服务器文件失败: {}", e))?;
            }
        }

        Ok(())
    }

    /// 兼容旧接口，默认仅从列表移除
    pub fn delete_server(&self, id: &str) -> Result<(), String> {
        self.remove_from_list(id)
    }

    pub fn get_logs(&self, id: &str, since: usize) -> Vec<String> {
        let logs = self.logs.lock().unwrap();
        if let Some(v) = logs.get(id) {
            if since < v.len() { v[since..].to_vec() } else { Vec::new() }
        } else { Vec::new() }
    }

    fn append_log(&self, id: &str, msg: &str) {
        if let Ok(mut logs) = self.logs.lock() {
            if let Some(v) = logs.get_mut(id) { v.push(msg.to_string()); }
        }
    }

    pub fn stop_all_servers(&self) {
        let ids: Vec<String> = self.processes.lock().unwrap().keys().cloned().collect();
        for id in ids { let _ = self.stop_server(&id); }
    }

    pub fn request_commands(&self, id: &str) -> Result<(), String> {
        let is_running = {
            let mut procs = self.processes.lock().unwrap();
            if let Some(child) = procs.get_mut(id) {
                match child.try_wait() {
                    Ok(Some(_)) => { procs.remove(id); false }
                    Ok(None) => true,
                    Err(_) => { procs.remove(id); false }
                }
            } else { false }
        };

        if !is_running {
            return Err("服务器未运行".to_string());
        }

        self.send_command(id, "help")?;
        Ok(())
    }

    pub fn get_commands(&self, id: &str) -> Vec<String> {
        {
            let cache = self.commands_cache.lock().unwrap();
            if let Some(cmds) = cache.get(id) {
                if !cmds.is_empty() {
                    return cmds.clone();
                }
            }
        }

        let logs = self.logs.lock().unwrap();
        let mut commands = Vec::new();

        if let Some(log_lines) = logs.get(id) {
            commands = parse_help_from_logs(log_lines);
        }

        if !commands.is_empty() {
            let mut cache = self.commands_cache.lock().unwrap();
            cache.insert(id.to_string(), commands.clone());
        }

        if commands.is_empty() {
            commands = get_default_minecraft_commands();
        }

        commands
    }

    pub fn clear_commands_cache(&self, id: &str) {
        let mut cache = self.commands_cache.lock().unwrap();
        cache.remove(id);
    }
}

fn parse_help_from_logs(logs: &[String]) -> Vec<String> {
    let mut commands = Vec::new();

    for line in logs.iter().rev().take(500) {
        let clean_line = strip_ansi_codes(line);

        if let Some(info_pos) = clean_line.find("INFO]:") {
            let content = clean_line[info_pos + 6..].trim();

            if content.starts_with('/') {
                if let Some(colon_pos) = content[1..].find(':') {
                    let cmd = content[1..colon_pos + 1].trim().to_lowercase();
                    if !cmd.is_empty() && cmd.len() <= 30 && is_valid_command_name(&cmd) {
                        if !commands.contains(&cmd) {
                            commands.push(cmd);
                        }
                    }
                }
            }
        }

        let trimmed = clean_line.trim();
        if trimmed.starts_with('/') {
            if let Some(colon_pos) = trimmed[1..].find(':') {
                let cmd = trimmed[1..colon_pos + 1].trim().to_lowercase();
                if !cmd.is_empty() && cmd.len() <= 30 && is_valid_command_name(&cmd) {
                    if !commands.contains(&cmd) {
                        commands.push(cmd);
                    }
                }
            }
        }
    }

    commands.sort();
    commands.dedup();
    commands
}
fn strip_ansi_codes(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let mut chars = s.chars().peekable();

    while let Some(&ch) = chars.peek() {
        if ch == '\x1b' {
            chars.next();
            if chars.peek() == Some(&'[') {
                chars.next();
                while let Some(&c) = chars.peek() {
                    chars.next();
                    if c.is_ascii_alphabetic() {
                        break;
                    }
                }
            }
        }
        else if ch == '[' {
            let mut buf = Vec::new();
            let mut temp_chars = chars.clone();
            temp_chars.next();
            let mut found_m = false;
            let mut is_ansi = true;

            while let Some(&c) = temp_chars.peek() {
                if c == 'm' {
                    found_m = true;
                    temp_chars.next();
                    break;
                } else if c.is_ascii_digit() || c == ';' {
                    buf.push(c);
                    temp_chars.next();
                } else {
                    is_ansi = false;
                    break;
                }
            }

            if found_m && is_ansi && !buf.is_empty() {
                chars = temp_chars;
            } else {
                result.push(ch);
                chars.next();
            }
        } else {
            result.push(ch);
            chars.next();
        }
    }

    result
}

fn is_valid_command_name(cmd: &str) -> bool {
    !cmd.is_empty() && cmd.chars().all(|c| c.is_alphanumeric() || c == '-' || c == '_')
}

fn parse_tab_completions(logs: &[String]) -> Vec<String> {
    let mut completions = Vec::new();

    for line in logs.iter().rev().take(20) {
        let clean_line = strip_ansi_codes(line);

        if clean_line.contains("<--[HERE]") {
            if let Some(pos) = clean_line.find("<--[HERE]") {
                let before = clean_line[..pos].trim();
                if let Some(last_word) = before.split_whitespace().last() {
                    let completion = last_word.trim().to_string();
                    if !completion.is_empty() && !completions.contains(&completion) {
                        completions.push(completion);
                    }
                }
            }
        }

        if clean_line.contains(',') && !clean_line.contains("INFO]:") {
            for part in clean_line.split(',') {
                let completion = part.trim().to_string();
                if !completion.is_empty() 
                    && completion.len() <= 30 
                    && is_valid_command_name(&completion)
                    && !completions.contains(&completion) {
                    completions.push(completion);
                }
            }
        }
    }

    completions
}

fn get_default_minecraft_commands() -> Vec<String> {
    vec![
        "help".into(), "list".into(), "stop".into(), "say".into(),
        "time".into(), "weather".into(), "gamemode".into(), "difficulty".into(),
        "give".into(), "tp".into(), "teleport".into(), "kill".into(),
        "kick".into(), "ban".into(), "pardon".into(), "op".into(), "deop".into(),
        "whitelist".into(), "gamerule".into(), "save-all".into(), "save-on".into(),
        "save-off".into(), "seed".into(), "summon".into(), "clear".into(),
        "effect".into(), "enchant".into(), "experience".into(), "xp".into(),
        "fill".into(), "setblock".into(), "clone".into(), "execute".into(),
        "scoreboard".into(), "team".into(), "title".into(), "tellraw".into(),
        "msg".into(), "tell".into(), "w".into(), "me".into(), "trigger".into(),
        "advancement".into(), "recipe".into(), "loot".into(), "data".into(),
        "datapack".into(), "function".into(), "schedule".into(), "reload".into(),
        "forceload".into(), "locate".into(), "locatebiome".into(), "setworldspawn".into(),
        "spawnpoint".into(), "spreadplayers".into(), "worldborder".into(),
        "bossbar".into(), "particle".into(), "playsound".into(), "stopsound".into(),
        "attribute".into(), "spectate".into(), "defaultgamemode".into(),
        "tps".into(), "plugins".into(), "pl".into(), "version".into(), "ver".into(),
        "timings".into(), "paper".into(), "spigot".into(), "restart".into(),
    ]
}

fn get_data_dir() -> String {
    // 使用软件根目录（可执行文件所在目录）
    if let Ok(exe_path) = std::env::current_exe() {
        if let Some(exe_dir) = exe_path.parent() {
            let data_dir = exe_dir.to_path_buf();
            println!("数据目录: {}", data_dir.display());
            return data_dir.to_string_lossy().to_string();
        }
    }

    // 如果获取失败，使用当前工作目录
    println!("警告: 无法获取可执行文件目录，使用当前目录");
    ".".to_string()
}

fn find_server_jar(modpack_path: &std::path::Path) -> Result<String, String> {
    // 常见的服务端JAR文件名模式
    let patterns = vec![
        "server.jar",
        "forge.jar",
        "fabric-server.jar",
        "minecraft_server.jar",
        "paper.jar",
        "spigot.jar",
        "purpur.jar",
    ];

    // 首先尝试精确匹配
    for pattern in &patterns {
        let jar_path = modpack_path.join(pattern);
        if jar_path.exists() {
            return Ok(jar_path.to_string_lossy().to_string());
        }
    }

    // 如果没有精确匹配，查找所有.jar文件
    let entries = std::fs::read_dir(modpack_path)
        .map_err(|e| format!("无法读取文件夹: {}", e))?;

    let mut jar_files = Vec::new();
    for entry in entries {
        if let Ok(entry) = entry {
            let path = entry.path();
            if path.is_file() {
                if let Some(ext) = path.extension() {
                    if ext == "jar" {
                        jar_files.push(path);
                    }
                }
            }
        }
    }

    if jar_files.is_empty() {
        return Err("整合包文件夹中未找到JAR文件".to_string());
    }

    // 如果只有一个JAR文件，直接使用
    if jar_files.len() == 1 {
        return Ok(jar_files[0].to_string_lossy().to_string());
    }

    // 如果有多个JAR文件，优先选择包含服务端关键词的文件
    for jar in &jar_files {
        if let Some(name) = jar.file_name() {
            let name_lower = name.to_string_lossy().to_lowercase();
            if name_lower.contains("server")
                || name_lower.contains("forge")
                || name_lower.contains("fabric")
                || name_lower.contains("mohist")
                || name_lower.contains("paper")
                || name_lower.contains("spigot")
                || name_lower.contains("purpur")
                || name_lower.contains("bukkit")
                || name_lower.contains("catserver")
                || name_lower.contains("arclight") {
                return Ok(jar.to_string_lossy().to_string());
            }
        }
    }

    // 如果都不匹配，返回第一个JAR文件
    Ok(jar_files[0].to_string_lossy().to_string())
}

fn load_servers(dir: &str) -> Vec<ServerInstance> {
    let p = std::path::Path::new(dir).join(DATA_FILE);
    if !p.exists() { return Vec::new(); }
    std::fs::read_to_string(&p).ok().and_then(|c| serde_json::from_str(&c).ok()).unwrap_or_default()
}
fn save_servers(dir: &str, servers: &[ServerInstance]) {
    let p = std::path::Path::new(dir).join(DATA_FILE);
    if let Ok(j) = serde_json::to_string_pretty(servers) { let _ = std::fs::write(&p, j); }
}

fn copy_dir_recursive(src: &std::path::Path, dst: &std::path::Path) -> std::io::Result<()> {
    if !dst.exists() {
        std::fs::create_dir_all(dst)?;
    }

    for entry in std::fs::read_dir(src)? {
        let entry = entry?;
        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());

        if src_path.is_dir() {
            copy_dir_recursive(&src_path, &dst_path)?;
        } else {
            std::fs::copy(&src_path, &dst_path)?;
        }
    }

    Ok(())
}
